# 질문
mejai_Guideline.md의 지침상 구현 계획을 확인하고 
현재 서비스에 구현된 
[에이전트, 평가/관리, 지식 베이스, 규칙] 항목의 기능 목적과 구현 정도를 정리해주세요.

내용은 reply 폴더에 질문과 답변에 대해 터미널에 기록되는 그대로 출력해주세요.

# 답변
mejai_Guideline.md 기준 구현 계획은 단계별 진행(Exit Criteria)이며, 운영자 콘솔 핵심 화면에 /app/agents, /app/eval, /app/kb, /app/rules가 포함됩니다. `docs/mejai_Guideline.md` 또한 진행 현황 문서에서 Phase 2 UI 구현 완료, Phase 3 백엔드/연동(규칙·KB 관리 포함) 미완으로 명시되어 있습니다. `docs/단계별_구현_체크리스트_및_검증.md`

항목별 정리

1) 에이전트
- 기능 목적(지침): 운영자 콘솔에서 에이전트 목록/생성/관리 화면 제공(핵심 화면 목록에 포함). `docs/mejai_Guideline.md`
- 구현 정도(현재 서비스):
  - /app/agents는 하드코딩된 1개 에이전트 목록만 표시하고 옵션 버튼만 존재합니다. `src/app/app/agents/page.tsx`
  - /app/agents/new는 로컬 상태 입력 → 토스트 표시 → 목록으로 이동만 수행하며 서버/API/DB 저장이 없습니다. `src/app/app/agents/new/page.tsx`
  - 에이전트 전용 API 라우트가 없습니다. `src/app/api`
  → UI 스케치 수준(데이터 저장/관리 미구현).

2) 평가/관리
- 기능 목적(지침): F-B3 “AI 대체 용이성” 평가/관리(A/B/C 등급, 근거 기반, 라우팅 규칙 반영). `docs/mejai_Guideline.md`
- 구현 정도(현재 서비스): /app/eval 화면은 고정 데이터 카드만 렌더링하며 입력/저장/규칙 연동이 없습니다. `src/app/app/eval/page.tsx`
  → UI 스케치 수준(평가 로직/저장/연동 미구현).

3) 지식 베이스
- 기능 목적(지침): F-B4 문서 등록/수정/버전/적용 범위 관리 및 RAG 근거 관리, 개선 워크플로에 반영. `docs/mejai_Guideline.md`
- 구현 정도(현재 서비스):
  - UI: 목록/생성/편집/삭제 화면 구현. `src/app/app/kb/page.tsx`, `src/app/app/kb/new/page.tsx`, `src/app/app/kb/[id]/page.tsx`
  - API: GET/POST /api/kb, GET/PATCH/DELETE /api/kb/[id], GET /api/kb/metrics 구현. `src/app/api/kb/route.ts`, `src/app/api/kb/[id]/route.ts`, `src/app/api/kb/metrics/route.ts`
  - DB 연동: Supabase knowledge_base 테이블에 저장/버전 관리( parent_id, 활성/비활성, bumpVersion )가 구현됨.
  - 미구현: RAG 인덱싱/검색/LLM 응답 반영, 규칙/평가와의 자동 연동은 코드상 확인되지 않으며 체크리스트에서도 “지식 베이스(KB) 문서 관리”가 Phase 3 미완 상태로 남아 있음. `docs/단계별_구현_체크리스트_및_검증.md`
  → CRUD/버전 관리 UI+API는 부분 구현, RAG 운영 흐름은 미구현.

4) 규칙
- 기능 목적(지침): MCP/라우팅/에스컬레이션 규칙 조정 화면 제공. `docs/mejai_Guideline.md`
- 구현 정도(현재 서비스): /app/rules는 예시 카드만 표시하며 저장/편집/적용 API 또는 DB 연동이 없습니다. `src/app/app/rules/page.tsx`
  → UI 스케치 수준(규칙 관리 로직/연동 미구현).

# 추가 질문
이러한 흐름에 입각하여 MCP는 어떤 요소가 대체하고 있는지 확인해주세요.
그리고 각 기능의 구현상 차이를 2026-01-26_15-21-30.md 파일에 이어서 답해주세요

A. LLM의 역할 (대화/추론/결정)

LLM은 “말”을 생성하는 것뿐 아니라, 통화 흐름에서 다음을 담당합니다.

사용자의 발화 의도 파악(환불/배송/불만/제품문의/AS 등)

브랜드 정책과 KB 근거를 바탕으로 답변 구성

필요한 경우 툴 호출 결정(주문조회, 본인확인, 티켓 생성 등)

안전 정책(민감정보/법률/의료 등) 준수 및 에스컬레이션 결정

권장: **“LLM 단독”이 아니라 “오케스트레이터가 LLM을 통제”**하는 구조

B. MCP의 역할 (툴/시스템 통합을 표준화)

MCP를 쓰면, LLM이 직접 DB나 내부 API를 무작정 두드리는 형태가 아니라:

“주문조회”, “배송추적”, “환불정책 조회”, “상담 티켓 생성”, “인증(OTP) 발송” 같은 기능을
표준화된 Tool 서버들로 제공할 수 있습니다.

테넌트(브랜드)별로 허용된 Tool만 노출하고, 파라미터 스키마를 엄격히 강제할 수 있습니다.

운영 측면에서 “브랜드 A는 Shopify, 브랜드 B는 카페24, 브랜드 C는 자체 ERP”처럼
백엔드가 달라도 LLM 입장에서는 동일한 인터페이스로 쓰게 만들 수 있습니다.

정리하면:

MCP = “LLM이 쓸 수 있는 안전한 기능 카탈로그”를 제공하는 레이어

도구 호출의 권한/감사로그/속도제한/마스킹을 중앙에서 수행하기 좋습니다.

C. 지식베이스(KB)의 역할 (사실/정책/문서 근거)

전화 CS에서 KB는 환각 방지의 핵심입니다.

FAQ, 정책, 약관, 공지, 상품 스펙, AS 규정, 배송/반품 조건 등

“최신성”이 중요(정책 변경, 공지 업데이트)

권장 구성:

문서 저장소(원본) + 인덱싱 파이프라인 + 벡터검색 + 키워드검색(하이브리드)

브랜드별로 논리적 분리(tenant namespace) 필수

검색 결과는 LLM에게 근거로만 제공하고, 답변에는 근거 기반 문장만 허용하는 가드레일을 둡니다.

4) 권장 전체 흐름 (End-to-End Call Flow)

아래 흐름이 “전화 한 통”의 표준 파이프라인입니다.

수신/라우팅

전화가 플랫폼 번호로 들어옴

DID(수신번호)로 tenant_id 조회

해당 tenant의 “인사말/언어/보이스/정책/툴셋/KB” 로딩

오디오 스트리밍

ASR이 실시간으로 고객 발화를 텍스트로 변환

동시에 VAD(무음 감지), barge-in(말 끊고 끼어들기) 처리

세션 상태 관리

통화 세션에 다음 상태를 유지
(예: 인증 전, 주문번호 확인, 배송조회 중, 환불정책 안내, 상담원 전환)

오케스트레이터 → LLM 호출

시스템 프롬프트에 다음을 결합

브랜드 CS 규칙(정책)

금지/필수 문구(컴플라이언스)

현재 세션 상태

최근 대화 요약 + 마지막 발화

필요한 경우 KB 검색(RAG) 선행

필요한 경우 MCP tool 호출로 사실 조회(주문/배송/회원)

툴 호출(MCP) + 결과 반영

LLM이 “배송조회” 툴 호출 결정

오케스트레이터가 MCP tool 실행(권한/마스킹/감사로그)

결과를 LLM에게 전달 → 답변 생성

가드레일/정책 검사

답변이 브랜드 정책 위반/법적 리스크/민감정보 포함 여부 확인

위반 시 재작성 또는 즉시 에스컬레이션

TTS로 음성 응답

LLM 답변 → TTS → 고객에게 송출

동시에 대화 로그/지표 저장

해결/종료 또는 사람 상담원 전환

해결되면 요약 + 티켓/메모 저장 후 종료

해결 불가/고객 요청/분쟁/욕설/위험 이슈면 Handoff

상담원에게: 통화 요약, 고객 의도, 이미 확인한 정보, 추천 답변, 관련 문서 근거를 전달

5) “브랜드 CS 규칙”을 어떻게 모델링할 것인가

브랜드가 등록하는 규칙은 단순 텍스트로만 받으면 운영이 어렵습니다. 권장 방식은:

정책을 3층으로 분리

Hard Rules(절대 규칙)

법/컴플라이언스/금지 표현/개인정보 처리/환불 불가 조건 등

위반 시 무조건 차단/에스컬레이션

Procedural Flows(절차형 플레이북)

“배송 지연 문의 시: 주문번호 요청 → 조회 → ETA 안내 → 보상 기준 안내 …”

통화는 절차가 중요하므로 상태 머신처럼 관리하면 안정적입니다.

Tone & Brand Voice(말투/브랜딩)

존댓말, 간결/친절, 사과문 톤, 금지 단어 등

LLM에는 “창의성”보다 “정확성과 절차 준수”가 중요하므로,
브랜드 규칙은 **구조화(폼/템플릿)**해서 받는 것이 좋습니다.

6) 추가로 꼭 고려해야 하는 설계 포인트
A. 본인확인/개인정보

전화 CS는 주문/환불/주소 등 개인정보를 다룹니다.

**인증 플로우(주문번호+휴대폰 뒷자리 / SMS OTP / 계정 로그인 링크 등)**를 제품 차원에서 제공해야 합니다.

LLM은 원문 PII를 보지 않도록 마스킹/토큰화가 유리합니다.

B. 환각 방지(“사실”은 KB+툴에서만)

배송 상태/환불 상태/재고/가격 같은 사실은
KB 또는 Tool 결과로만 말하게 제한해야 합니다.

“근거 없는 단정”을 정책적으로 금지.

C. 지연시간(Latency)

전화는 지연에 매우 민감합니다.

스트리밍 ASR + 짧은 턴 + 부분 TTS 스트리밍이 필요

LLM 호출을 매 턴 길게 하면 체감 품질이 급락합니다.

해결 전략:

의도 분류용 경량 모델(또는 룰) + LLM은 핵심 턴에만

KB 검색은 필요한 경우에만

답변을 길게 말하지 않고 단계적으로

D. 품질 측정/운영

KPI: 해결률, 평균 통화시간, 에스컬레이션율, 재통화율, 금칙 위반률, 근거 인용률

콜 샘플링/리뷰 툴, 자동 평가(LLM-as-judge)는 운영 필수입니다.


# 추가 답변
MCP가 대체/담당하는 요소(요청하신 E2E 흐름 기준)
- LLM의 “툴 호출 결정/실행” 부분을 **MCP가 표준화된 Tool 카탈로그+권한/스키마/감사/마스킹**으로 대체합니다.
- 오케스트레이터에서 “브랜드별 허용 Tool 노출, 파라미터 스키마 강제, 호출 결과 전달”을 중앙에서 수행합니다.
- 즉, **LLM이 직접 DB/API를 호출하지 않고 MCP 레이어를 통해 안전하게 기능을 호출**하게 만드는 역할입니다.

현재 구현과의 차이(2026-01-26 기준 코드)
- MCP 레이어 자체(툴 카탈로그/권한/감사/마스킹/속도제한) 구현 없음.
  - /app/rules는 규칙 카드만 표시하는 UI 스케치이며, 실제 MCP 규칙/툴 노출 정책과 연결되지 않습니다. `src/app/app/rules/page.tsx`
- 오케스트레이터 기반의 Tool 호출 흐름 미구현.
  - LLM/ASR/TTS/툴 호출을 묶는 오케스트레이터 서버가 아직 없고, Phase 3에서 “통화 → LLM → KB → TTS 루프 검증”이 미완으로 남아 있습니다. `docs/단계별_구현_체크리스트_및_검증.md`
- MCP가 대체해야 할 실제 기능(주문조회, 배송추적, 환불정책 조회, 티켓 생성, OTP 등)에 대한 API/Tool 서버가 코드에 존재하지 않습니다.
  - 현재 API는 세션/턴/오디오/이벤트/리뷰/KB 등 운영 로그 중심이며, 주문/배송/티켓/인증 Tool API는 확인되지 않습니다. `src/app/api`
- KB는 CRUD/버전 관리 API와 UI가 부분 구현되어 있으나, **MCP/툴 호출과 결합된 정책 집행 레이어**는 없습니다.
  - KB 검색 결과를 LLM에 주입하고 답변을 정책 검사하는 파이프라인이 코드에 존재하지 않습니다. `src/app/app/kb/*`, `src/app/api/kb/*`

정리하면, 현재 코드에서 MCP가 대체해야 할 요소(툴 표준화/권한/감사/마스킹/속도제한/브랜드별 노출)는 아직 구현되어 있지 않고, 규칙 페이지는 UI 목업 수준이며 실제 오케스트레이터·툴 호출 파이프라인과 연결되어 있지 않습니다.

# 추가 질문
현재 구현된 것은 "디자인"입니다.
제가 원하는 것은 실제로 MCP가 동작할 수 있도록 하는 "기능"입니다.

기능 설계부터 reply 폴더에 남겨주세요.
디자인은 이후에 생각하겠습니다.

# 추가 답변
아래는 “MCP가 실제로 동작”하기 위한 기능 설계안입니다. (UI/디자인 제외, 기능/데이터/흐름 중심)

1) 목표 범위(MCP 기능이 대체/담당할 것)
- LLM이 직접 DB/API 호출하지 않도록 “도구 카탈로그 + 권한/감사/속도제한/마스킹 + 실행 결과 표준화”를 제공
- 테넌트(브랜드)별로 허용된 Tool만 노출, 동일 인터페이스로 다양한 백엔드(Shopify/카페24/ERP) 연결
- 통화 세션 상태와 연동하여 tool 호출 → 결과를 LLM에 안전하게 전달

2) 아키텍처(서버 컴포넌트)
- Orchestrator(봇 서버): 대화 상태, LLM 호출, Tool 호출 판단
- MCP Gateway: Tool 카탈로그, 권한/정책/스키마 검증, 라우팅, 감사/속도제한/마스킹
- Tool Adapters: Shopify, 카페24, ERP, SMS/OTP, 티켓 시스템 등 실제 백엔드 연동 모듈
- KB/RAG: 문서 검색 결과 제공(사실 근거)

요청 흐름(요약)
1) LLM이 tool 요청 제안(툴명+파라미터)
2) Orchestrator가 MCP Gateway 호출
3) MCP가 정책/스키마/권한/속도제한/마스킹 적용
4) MCP가 해당 Tool Adapter 실행
5) MCP가 결과를 표준 응답으로 반환
6) Orchestrator가 LLM에 결과 전달 후 답변 생성

3) 핵심 데이터 모델(테이블/스키마)
- mcp_tools
  - id, name, description, provider_type(shopify/cafe24/erp/sms/ticket), schema_json, is_active
- mcp_tool_versions
  - tool_id, version, schema_json, created_at, created_by
- mcp_tool_permissions
  - org_id, tool_id, is_allowed, allowed_scopes(read/write), rate_limit_per_min
- mcp_tool_endpoints
  - tool_id, env(prod/sandbox), base_url, auth_type(api_key/oauth2), auth_ref
- mcp_tool_audit_logs
  - org_id, session_id, tool_id, tool_name, request_payload, response_payload, status, latency_ms, masked_fields
- mcp_tool_rate_limits
  - org_id, tool_id, window_sec, max_requests
- mcp_tool_masking_rules
  - org_id, tool_id, field_paths, mask_strategy

4) 표준 Tool 호출 스키마
- Tool 요청 (LLM → Orchestrator → MCP)
  {
    "tool": "order.lookup",
    "version": "v1",
    "params": { "order_id": "...", "email": "..." },
    "tenant_id": "org_uuid",
    "session_id": "session_uuid"
  }
- Tool 응답 (MCP → Orchestrator → LLM)
  {
    "tool": "order.lookup",
    "version": "v1",
    "status": "success|error",
    "data": { "order_status": "배송중", "eta": "2026-01-28" },
    "error": { "code": "NOT_FOUND", "message": "..." },
    "meta": { "latency_ms": 120, "masked": ["email"] }
  }

5) 정책/검증 레이어
- 스키마 검증: JSON Schema로 params 필드 엄격 검증
- 권한 검증: tenant별 허용 Tool, scope 검사
- 속도 제한: tenant+tool 단위 토큰 버킷
- 마스킹: PII 필드/응답값 마스킹 룰 적용
- 감사 로그: 모든 호출 기록 저장

6) 실행 단계(구현 순서)
Phase 1: MCP Gateway 최소 기능
- Tool registry(도구 목록) + tenant 권한 스키마
- JSON Schema 검증 + 권한 검사
- 감사 로그 저장
- 최소 1개 Tool adapter(예: 배송조회 dummy or sandbox)

Phase 2: Tool 다양화
- Shopify 주문조회
- 카페24 주문조회
- SMS/OTP 발송
- 티켓 생성

Phase 3: 운영 안정화
- 속도 제한, 마스킹 룰
- 실패 재시도/타임아웃
- 관리자 정책 변경 기록

7) 현재 코드베이스 대비 구현 차이
- MCP Gateway/Tool Registry/Tool Adapter 코드가 없음
- Tool 권한/스키마/마스킹/감사 로그 테이블 없음
- Orchestrator에서 MCP 호출 파이프라인 없음
- 규칙 UI는 단순 카드(기능 연결 없음)

8) 다음 액션(기능 구현 관점)
- 서버 디렉터리에 MCP Gateway 라우트/서비스 추가
- DB 마이그레이션(위 테이블)
- 샘플 Tool 1~2개 구현
- Orchestrator에서 tool 호출 흐름 연결

원하시면 위 설계를 기준으로 실제 구현(서버 코드 + DB 스키마 + API 계약)부터 바로 진행하겠습니다.
